import React, { useEffect, useState } from 'react';
import { View, Text, TextInput, Button, ScrollView, Platform } from 'react-native';
import { Transaction } from './Transaction';

import * as SecureStore from 'expo-secure-store';
import * as Application from 'expo-application';

import CryptoJS from 'crypto-js';

import * as Crypto from 'expo-crypto';
import * as secp from '@noble/secp256k1';
import { keccak_256 } from '@noble/hashes/sha3';
import { hexToBytes, bytesToHex } from '@noble/hashes/utils';

import QRCode from 'react-native-qrcode-svg';

// const ec = new EC('secp256k1');

function isPrivateKeyValid(privateKey: string) {
  // Check if the generated bytes are a valid private key
  // Note: In a real-world scenario, you should also check if the private key is not already in use.
  if (secp.utils.isValidPrivateKey(privateKey)) {
    return true;
  } else {
    // throw new Error('Generated invalid private key');
    return false;
  }
}

async function isEncryptedPrivateKeyStored() {
  const encryptedPrivateKey = await SecureStore.getItemAsync('encryptedPrivateKey');
  return encryptedPrivateKey !== null;
}

async function getEncryptedPrivateKey() {
  const encryptedPrivateKey = await SecureStore.getItemAsync('encryptedPrivateKey');
  return encryptedPrivateKey;
}

export function Wallet({ blockchain }: { blockchain: any }) {
  const [UUID, setUUID] = useState('');
  const [uniqueId, setUniqueId] = useState<string | null>(null);

  const [password, setPassword] = useState('');
  const [oldPassword, setOldPassword] = useState('');
  const [newPassword, setNewPassword] = useState('');

  const [privateKeyI, setPrivateKeyI] = useState('');
  const [privateKey, setPrivateKey] = useState('');
  const [publicKey, setPublicKey] = useState('');
  const [isEncryptedPrivateKeyStored, setIsEncryptedPrivateKeyStored] = useState(false);
  const [myAddress, setMyAddress] = useState('');
  const [recipientAddress, setRecipientAddress] = useState('');
  const [amount, setAmount] = useState('');
  const [balance, setBalance] = useState(0);

  useEffect(() => {
    if (Platform.OS === 'android') {
      setUniqueId(Application.getAndroidId()); // Not ANDROID_ID but works as a unique ID
    } else {
      setUniqueId('Not an Android device');
    }
  }, []);

  const generateWallet = async () => {
    const UUID = Crypto.randomUUID(); // Generate a random UUID

    // const hash = await Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, privateKeyHex); // Create the hash of the random data
    const randomBytes = new Uint8Array(32); // Generate a random 256-bit number
    await Crypto.getRandomValues(randomBytes); // Use the Expo Crypto to generate random bytes
    const privateKeyHex = Buffer.from(randomBytes).toString('hex'); // Convert the byte array to a hex string (optional, only for logging)
    setPrivateKeyI(privateKeyHex);

    const key = CryptoJS.SHA256(password).toString(); // Hash the password to create a key for encryption
    const encrypted = CryptoJS.AES.encrypt(privateKeyHex, key).toString(); // Encrypt the private key using the password
    await SecureStore.setItemAsync('encryptedPrivateKey', encrypted); // Store the encrypted private key in secure storage
    setIsEncryptedPrivateKeyStored(true); // Update the state to indicate that the private key is stored
    console.log('ðŸ” Private key created, encrypted and saved! ðŸ”', encrypted);

    const publicKeyCompressed = secp.getPublicKey(randomBytes, true); // Use the randomBytes directly as the private key to create the public compressed format key
    const publicKeyUncompressed = secp.getPublicKey(randomBytes, false); // Uncompressed format

    const pubKeyWithoutPrefix = publicKeyUncompressed.slice(1); // 1. Remove the first byte (0x04) from the uncompressed public key (64 bytes)
    const addressHash = keccak_256(pubKeyWithoutPrefix); // 2. Keccak256 hash of the public key
    const addressBytes = addressHash.slice(-20); // 3. Take the last 20 bytes
    const cryptoAddress = '0x' + bytesToHex(addressBytes); // 4. Convert to hex and prefix with "0x"
    // setPublicKey(Buffer.from(publicKeyUncompressed).toString('hex'));
    // setPublicKeyCompressed(Buffer.from(publicKeyCompressed).toString('hex'));
    setMyAddress(cryptoAddress);
    console.log('ðŸ” Address created! ðŸ”', cryptoAddress);

    //const newBalance = blockchain.getBalanceOfAddress(publicKeyGenerated);
    //setBalance(newBalance);
  };

  const decryptPrivateKey = async () => {
    const encryptedPrivateKey = await SecureStore.getItemAsync('encryptedPrivateKey'); // Restore the encrypted private key from secure storage
    const key = CryptoJS.SHA256(password).toString(); // Derive AES key from password
    if (!encryptedPrivateKey) {
      throw new Error('âŒ Encrypted private key not found.');
    }
    const decrypted = CryptoJS.AES.decrypt(encryptedPrivateKey, key); // Decrypt AES
    const privateKeyHex = decrypted.toString(CryptoJS.enc.Utf8); // Decode to UTF-8
    if (!privateKeyHex) {
      throw new Error('âŒ Decryption failed. Possibly wrong password or corrupted data.');
    }
    setPrivateKey(privateKeyHex);
  };

  const changePassword = async () => {
    // TODO: Implement password change logic
    // This would typically involve decrypting the private key with the old password and re-encrypting it with the new password.
    if (oldPassword !== password) {
      throw new Error('âŒ The password typed does not match with the one in the registry.');
    } else {
      const encryptedPrivateKey = await SecureStore.getItemAsync('encryptedPrivateKey'); // Restore the encrypted private key from secure storage
      if (!encryptedPrivateKey) {
        throw new Error('âŒ Encrypted private key not found.');
      }
      const key = CryptoJS.SHA256(password).toString(); // Derive AES key from password
      const decrypted = CryptoJS.AES.decrypt(encryptedPrivateKey, key); // Decrypt AES
      const privateKeyHex = decrypted.toString(CryptoJS.enc.Utf8); // Decode to UTF-8
      if (!privateKeyHex) {
        throw new Error('âŒ Decryption failed. Possibly wrong password or corrupted data.');
      }
      setPrivateKey(privateKeyHex);
      const newKey = CryptoJS.SHA256(newPassword).toString(); // Hash the password to create a key for encryption
      const encrypted = CryptoJS.AES.encrypt(privateKeyHex, newKey).toString(); // Encrypt the private key using the password
      await SecureStore.setItemAsync('encryptedPrivateKey', encrypted); // Store the encrypted private key in secure storage
      setIsEncryptedPrivateKeyStored(true); // Update the state to indicate that the private key is stored
      console.log(
        'ðŸ” Password changed and your Private key was encrypted and saved again! ðŸ”',
        encrypted
      );
    }
  };

  const sendTransaction = () => {
    if (!privateKey || !publicKey || !recipientAddress || !amount) {
      alert('Please fill all fields!');
      return;
    }

    // const key = ec.keyFromPrivate(privateKey);
    const transaction = new Transaction(publicKey, recipientAddress, parseFloat(amount));
    transaction.signTransaction(key); // Ensure Transaction has a 'sign' method

    try {
      blockchain.addTransaction(transaction);
      alert('Transaction added! Now mine pending transactions.');
    } catch (error: any) {
      alert('Error sending transaction: ' + error.message);
    }
  };

  const refreshBalance = () => {
    const newBalance = blockchain.getBalanceOfAddress(publicKey);
    setBalance(newBalance);
  };

  return (
    <View className="mb-2 rounded-md bg-white p-4 shadow-md">
      <Text className="mb-4 text-center text-2xl font-bold">Wallet</Text>

      {isEncryptedPrivateKeyStored ? (
        <>
          <View className="my-4 w-full items-center">
            {/* QR code box */}
            <View className="h-40 w-40 items-center justify-center rounded-md border border-gray-300 bg-white p-4">
              <QRCode value={myAddress} />
            </View>
            <Text className="mt-2 text-xs italic text-gray-500">Scan to send funds</Text>
          </View>

          <Text className="font-bold">My Crypto Address:</Text>
          <Text selectable className="mb-2 text-xs">
            {myAddress}
          </Text>

          <Text className="mt-2 font-bold">Balance: {balance}</Text>
          <Text className="mt-2 font-bold">UniqueID: {uniqueId}</Text>
          <Text className="mt-2 font-bold">PrivateKey: {privateKeyI}</Text>

          <Text className="mt-4 text-center italic text-gray-500">Decrypt the Private Key</Text>
          <View className="mt-4 space-y-2">
            <TextInput
              className="mb-2 rounded-md border border-gray-300 bg-white p-2"
              placeholder="Enter a password to reveal your wallet private key"
              secureTextEntry
              value={password}
              onChangeText={setPassword}
            />
            <Button title="Decrypt the Private Key" onPress={decryptPrivateKey} />
            <Text className="my-2 font-bold">PrivateKey: {privateKey}</Text>
          </View>

          <Text className="mt-4 text-center italic text-gray-500">Change your password</Text>
          <View className="mt-4 space-y-2">
            <TextInput
              className="mb-2 rounded-md border border-gray-300 bg-white p-2"
              placeholder="Old Password"
              secureTextEntry
              value={oldPassword}
              onChangeText={setOldPassword}
            />
            <TextInput
              className="mb-2 rounded-md border border-gray-300 bg-white p-2"
              placeholder="New Password"
              secureTextEntry
              value={newPassword}
              onChangeText={setNewPassword}
            />
            <Button title="Change Password" onPress={changePassword} />            
          </View>

          <Button title="Refresh Balance" onPress={refreshBalance} />

          <View className="mt-4 space-y-2">
            <TextInput
              className="rounded-md border border-gray-300 bg-white p-2"
              placeholder="Recipient Address"
              value={myAddress}
              onChangeText={setRecipientAddress}
            />
            <TextInput
              className="rounded-md border border-gray-300 bg-white p-2"
              placeholder="Amount"
              value={amount}
              onChangeText={setAmount}
              keyboardType="numeric"
            />
            <Button title="Send Transaction" onPress={sendTransaction} />
          </View>
        </>
      ) : (
        <>
          <Text className="mt-4 text-center italic text-gray-500">Create a wallet to begin.</Text>
          <View className="mt-4 space-y-2">
            <TextInput
              className="mb-2 rounded-md border border-gray-300 bg-white p-2"
              placeholder="Enter a password to secure your wallet"
              secureTextEntry
              value={password}
              onChangeText={setPassword}
            />
            <Button title="Generate Wallet" onPress={generateWallet} />
          </View>
        </>
      )}
    </View>
  );
}
