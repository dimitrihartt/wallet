import { useState } from 'react';
import { View, Text, TextInput, Button, ScrollView } from 'react-native';
import { Transaction } from './Transaction';

import * as Crypto from 'expo-crypto';
import * as secp from '@noble/secp256k1';
import { keccak_256 } from '@noble/hashes/sha3';
import { hexToBytes, bytesToHex } from '@noble/hashes/utils';

import QRCode from 'react-native-qrcode-svg';

// const ec = new EC('secp256k1');

export function Wallet({ blockchain }: { blockchain: any }) {
  const [UUID, setUUID] = useState('');
  const [privateKey, setPrivateKey] = useState('');
  const [publicKey, setPublicKey] = useState('');
  const [publicKeyCompressed, setPublicKeyCompressed] = useState('');
  const [myAddress, setMyAddress] = useState('');
  const [recipientAddress, setRecipientAddress] = useState('');
  const [amount, setAmount] = useState('');
  const [balance, setBalance] = useState(0);

  const generateWallet = async () => {
    // Generate a random UUID
    const UUID = Crypto.randomUUID();

    // Generate a random 256-bit number
    const randomBytes = new Uint8Array(32);
    await Crypto.getRandomValues(randomBytes);
    // Check if the generated bytes are a valid private key
    // Note: In a real-world scenario, you should also check if the private key is not already in use.
    const isValid = secp.utils.isValidPrivateKey(randomBytes);
    if (!isValid) {
      throw new Error('Generated invalid private key');
    }

    // Convert the byte array to a hex string (optional, only for logging)
    const randomHex = Buffer.from(randomBytes).toString('hex');

    // Use the randomBytes directly as the private key
    const publicKeyCompressed = secp.getPublicKey(randomBytes, true); // compressed format
    const publicKeyUncompressed = secp.getPublicKey(randomBytes, false); // uncompressed format

    // Create the hash of the random data
    // const hash = await Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, randomHex);

    // Creating the address from the public key
    // 1. Remove the first byte (0x04) from the uncompressed public key
    const pubKeyWithoutPrefix = publicKeyUncompressed.slice(1); // 64 bytes

    // 2. Keccak256 hash of the public key
    const addressHash = keccak_256(pubKeyWithoutPrefix);

    // 3. Take the last 20 bytes
    const addressBytes = addressHash.slice(-20);

    // 4. Convert to hex and prefix with "0x"
    const cryptoAddress = '0x' + bytesToHex(addressBytes);
    console.log('Address:', cryptoAddress);

    setUUID(UUID);
    setPrivateKey(randomHex);
    setPublicKey(Buffer.from(publicKeyUncompressed).toString('hex'));
    setPublicKeyCompressed(Buffer.from(publicKeyCompressed).toString('hex'));
    setMyAddress(cryptoAddress);

    //const newBalance = blockchain.getBalanceOfAddress(publicKeyGenerated);
    //setBalance(newBalance);
  };

  const sendTransaction = () => {
    if (!privateKey || !publicKey || !recipientAddress || !amount) {
      alert('Please fill all fields!');
      return;
    }

    // const key = ec.keyFromPrivate(privateKey);
    const transaction = new Transaction(publicKey, recipientAddress, parseFloat(amount));
    transaction.signTransaction(key); // Ensure Transaction has a 'sign' method

    try {
      blockchain.addTransaction(transaction);
      alert('Transaction added! Now mine pending transactions.');
    } catch (error: any) {
      alert('Error sending transaction: ' + error.message);
    }
  };

  const refreshBalance = () => {
    const newBalance = blockchain.getBalanceOfAddress(publicKey);
    setBalance(newBalance);
  };

  return (
    <View className="mb-2 rounded-md bg-white p-4 shadow-md"> 
    <Text className="mb-4 text-center text-2xl font-bold">Wallet</Text>
  
    <Button title="Generate Wallet" onPress={generateWallet} />
  
    {publicKey ? (
      <>
        <View className="my-4 w-full items-center">
          {/* QR code box */}
          <View className="h-40 w-40 items-center justify-center rounded-md border border-gray-300 bg-white p-4">
            <QRCode value={myAddress} />
          </View>
          <Text className="mt-2 text-xs italic text-gray-500">Scan to send funds</Text>
        </View>
          
        <Text className="font-bold">My Crypto Address:</Text>
        <Text selectable className="mb-2 text-xs">{myAddress}</Text>
  
        <Text className="mt-4 font-bold">UUID:</Text>
        <Text selectable className="mb-2 text-xs">{UUID}</Text>
  
        <Text className="mt-4 font-bold">Public Key:</Text>
        <Text selectable className="mb-2 text-xs">{publicKey}</Text>
  
        <Text className="mt-4 font-bold">Public Key Compressed:</Text>
        <Text selectable className="mb-2 text-xs">{publicKeyCompressed}</Text>
  
        <Text className="font-bold">Private Key:</Text>
        <Text selectable className="mb-2 text-xs">{privateKey}</Text>
  
        <Text className="mt-2 font-bold">Balance: {balance}</Text>
  
        <Button title="Refresh Balance" onPress={refreshBalance} />
  
        <View className="mt-4 space-y-2">
          <TextInput
            className="rounded-md border border-gray-300 bg-white p-2"
            placeholder="Recipient Address"
            value={myAddress}
            onChangeText={setRecipientAddress}
          />
          <TextInput
            className="rounded-md border border-gray-300 bg-white p-2"
            placeholder="Amount"
            value={amount}
            onChangeText={setAmount}
            keyboardType="numeric"
          />
          <Button title="Send Transaction" onPress={sendTransaction} />
        </View>
      </>
    ) : (
      <Text className="mt-4 text-center italic text-gray-500">
        Create or load a wallet to begin.
      </Text>
    )}
  </View>
  
  );
}
